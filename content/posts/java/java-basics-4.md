---
title: "Java基础知识4-锁"
date: 2020-10-07T14:23:52+08:00
tags: [java基础]
---

---
<!--more-->

# 1.0 锁类型

- 悲观锁
- 乐观锁
- 自旋锁
- 适应性自旋锁
- 无锁
- 偏向锁
- 轻量级锁
- 重量级锁
- 公平锁
- 非公平锁
- 可重入锁
- 非可重入锁
- 共享锁
- 排他锁

![111](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png)

## 悲观锁

> 对于同一个数据在并发操作，认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。

适合写操作多的场景，先加锁可以保证写操作时数据正确。

在Java中 synchronized 和 Lock的实现类都是悲观锁。

- ReadLock
- ReadLockView
- ReentrantLock
- WriteLock
- WriteLockView

## 乐观锁

> 认为自己在使用数据时不会有别的线程修改数据，不会添加锁，在更新数据前判断数据是否被更改，如果更改，则根据不同的实现方式执行不同的操作。

适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。

乐观锁在Java中使用的是无锁的方式，最常采用的方法是CAS（Compare And Swap（比较与交换））算法，Java原子类中的递增操作就通过CAS自旋实现的。

CAS: 

- 需要读写的内存值 V。
- 进行比较的值 A。
- 要写入的新值 B。

当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。

![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/c8703cd9.png)

## 自旋锁 

阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态切换需要耗费处理器时间。如果同步代码块重的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。

在许多场景中，同步最远的锁定时间很短，为了这一小段时间去切换线程，过于奢侈，如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。

![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/452a3363.png)

自旋锁虽然避免了线程切换的开销，但是要占用处理器的时间，如果锁被占用时间很短，自旋锁效果就非常好，但如果占用时间过长，
那么将会浪费处理器资源，所以自旋锁必须要有限度，在Java中默认为10次，通过 `-XX:PreBlockSpin` 来修改，如果没有获取到，则挂起。

## 适应性自旋锁

> 自旋的时间和次数不再固定，由前一次在同一个锁上的自旋时间及锁的拥有者状态来决定。

如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么JVM就认为这次自旋也是很有可能成功的，允许等待更长时间，
如果某个对象自旋很少成功，那么接下来尝试获取可能会省掉自选过程，直接阻塞。

## 无锁、偏向锁、轻量级锁、重量级锁

synchronized 通过 Monitor 实现锁，在对象头中，主要包括两部分数据：
- Mark Word
- Klass Pointer

Mark Word：

默认存储对象的HashCode，分代年龄和锁标志位信息。

Klass Pointer：

对象指向它的类元素的指针，JVM通过这个指针确定对象是哪个类的实例。

Monitor 是线程私有的数据结构，每个线程都有一个可用的 monitor record 列表，同时还有一个全局的可用列表。

每一个被锁住的对象都会和一个 monitor 关联，同时 monitor 中又一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。

Monitor是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的线程同步。

JDK1.6之前是使用 Mutex Lock 这种重量锁，1.6中引入了偏向锁和轻量级锁。

|锁状态|	存储内容|	存储内容|
|----|----|----|
无锁	|对象的hashCode、对象分代年龄、是否是偏向锁（0）|	01
偏向锁|	偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）|	01
轻量级锁	|指向栈中锁记录的指针|	00
重量级锁	|指向互斥量（重量级锁）的指针|	10

### 无锁
修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。

### 偏向锁
> 如果一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。

当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储偏向的线程ID，在线程进入或退出代码块时，不再通过CAS操作来加锁和解锁，而是检测 Mark Word 里是否
存储着指向当前线程的偏向锁，偏向锁只需要在置换线程ID时依赖一次CAS原子指令。

偏向锁只有遇到其它线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁，偏向锁的撤销需要等待全局安全点，它会暂停拥有偏向锁的线程，
判断对象是否处于锁定状态，撤销后恢复到无锁或者轻量级锁状态。

### 轻量级锁
> 当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级成轻量锁，其他线程会采取自选的形式获取锁，不会阻塞，从而提高性能。

在进入同步块的时候，如果同步对象为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储对象目前
的 Mark Word的拷贝，然后拷贝对象头中的 Mark Word 复制到锁记录中。

拷贝成功后，JVM将使用CAS操作尝试将对象头的 Mark Word 更新指向 Lock Record 的指针，并将 Lock Record 里的 owner指针指向对象的 Mark Word。

如果这个更新动作成功了，那么该线程就拥有了锁，并将对象更新处于轻量级锁状态。

如果失败了，会先检查 Mark Word 是否指向当前线程的栈帧，如果是 那就是拥有了锁，可以继续执行，如果不是，则说明多个线程竞争锁。

### 重量级锁

当锁升级为重量级锁的时候 等待线程会进入阻塞状态。


### 公平锁和非公平锁
> 公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。

> 非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。


### 可重入锁和非可重入锁

> 是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁

ReentrantLock和synchronized都是可重入锁

ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。

当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。

释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。

### 独享锁和共享锁

ReentrantLock和ReentrantReadWriteLock

ReentrantLock为独享锁



ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。

读锁是共享锁，写锁是独享锁。读写、写读、写写的过程互斥。
ReentrantReadWriteLock将state拆分为两位。高16位为读锁个数，低16位为写锁个数。
