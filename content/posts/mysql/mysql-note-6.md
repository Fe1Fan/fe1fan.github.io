---
title: "MySQL 笔记6：存储"
date: 2020-10-07T14:23:52+08:00
tags: [mysql]
---
<!--more-->
# 存储
本文以InnoDB为例，讲述MySQL InnoDB引擎的存储结构。

## 1.0 页
我们将数据放入MySQL，MySQL会写入磁盘文件，而真正的数据处理过程发生在内存中，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求，
还需要把内存中的数据刷新到磁盘，当我们从表中获取某些数据时，InnoDB采取的方式是：
将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16KB，也就是说，在一般情况下，一次最少从磁盘中读取16K的
内容到内存中，写入也是一次最少16KB。

## 2.0 行格式

当我们以记录为单位向表中插入数据，这些记录在磁盘上存放的格式被称为行格式或者记录格式。

InnoDB中的行格式如下：
- Compact
- Redundant
- Dynamic
- Compressed

指定行格式：

```sql
CREATE TABLE test ROW_FORMAT=Compact
ALTER TABLE test ROW_FORMAT=Compact
```

### 2.1 Compact

结构：
```shell
[变长字段长度列表][NULL值列表][记录头信息]  [列1的值][列2的值]...[列N的值]
|------------------------------------||--------------------------|
            记录额外信息                      记录真实数据
```

记录额外信息：

这部分信息是服务器为了描述这条记录而不得不添加的一些信息。

#### 2.1.1 变长字段长度列表

主要用于记录VARCHAR VARBINARY TEXT 这种不固定长度占用的字节数，**以逆序放**，所以说这些数据被分为两部分记录，一部分为真实的数据、一部分为占用的字节数。

假如表结构：
```sql
CREATE TABLE record_format_demo (
    ->     c1 VARCHAR(10),
    ->     c2 VARCHAR(10) NOT NULL,
    ->     c3 CHAR(10),
    ->     c4 VARCHAR(10)
    -> ) CHARSET=ascii ROW_FORMAT=COMPACT;
```

数据：

```shell
+------+-----+------+------+
| c1   | c2  | c3   | c4   |
+------+-----+------+------+
| aaaa | bbb | cc   | d    |
| eeee | fff | NULL | NULL |
+------+-----+------+------+
```

表使用ascii编码，所以每个字符只需要1个字节进行编码，所以长度为：


|列名|内容|长度|长度0x|
|----|----|----|----|
|c1|'aaaa'|4|0x04|
|c2|'bbb'|3|0x03|
|c4|'d'|1|0x01|

将这些长度倒叙存放，我们得到数据：
```shell
010304
```
所以 `[变长字段长度列表] = 010304`。

由于当前表采用ascii编码且c1、c2、c4字符串较短，长度用1个字节就可以表示，如果字符串较长时，就需要2个字节来表示。

InnoDB计算需要几个字节来表示的规则:

首先声明 W、M、L的意思
- W 

字符集表示一个字符最多需要的字节数，例如utf8 W=3（这里注意，MySQL utf8字符集采用最多3字节数，utf8mb4采用最多4字节数），gbk W=2，ascii W=1。

- M

对于VARCHAR(M) 这种可变长度的类型来说，这个类型最多存储M个字符（不是字节），所以说最多存储的字节数为 MxW。

- L

假设它实际存储的字符串占用的字节数是L。（这里的L并不是获取到的真实占用字节数，而是代表占用字节数的第一个字节）

InnoDB计算规则如下：

- 如果 `MxW <= 255` 那么采用1字节来表示真正的字符串占用字节数。 

  InnoDB在读记录的变长字段长度列表时，先查看表结构，如果某个变长字段允许储存的最大字节数不超过255，那么认为只是用1个字节来表示占用字节数。
- 如果 `MxW > 255` 
  - `L <= 127` 则采用1字节表示。
  - `L > 127` 则采用2字节表示。
  
  InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个字段允许存储最大字节数超过255时，假如值为 `0x7F` 二进制的 `0111 1111`，当读取到二进制的第一位为0时，
  那么该字节就是一个完整的字段长度，假如值为 `0x80` 二进制的 `1000 0000`，那么该字节为半个字段长度，当字段很长时，InnoDB会把一部分数据放到溢出页（后续），
  使得留在本页面中的长度使用两个字节也可存放。

[comment]: <> (- 假如当前字节数使用一字节来表示，那么他的最大值：)

[comment]: <> (  1111 1111)

[comment]: <> (  ---------)

[comment]: <> (  1 byte)

[comment]: <> (- 假如当前字段需要两个字节来表示，那么它的最小值为:)

[comment]: <> (  1000 0000 0000 0000)

[comment]: <> (  --------- ---------)

[comment]: <> (  1 byte    2 byte)
```
//这里记录一下，以防忘记
当第一个字节的二进制的第一位为0时，它的最大值为 0x7F，也就是二进制的 0111 1111，十进制的127
当第一个字节的二进制的第一位为1时，他的最小值为 0x80，也就是二进制的 1000 0000，十进制的128，最大值为255
//用7位二进制代表数字理论上为2^7=128个，为什么最大值127而不是128 ？因为有 000 0000 = 0 的情况
//8位二进制 255同上

//这里为什么要这么设计？（猜想）
在无法分辨当前字节数是需要一位还是两位来表示时：

那么当第一个字节的二进制的第一位为0时，最大值 0111 1111 代表着还有一位空余未使用到。

那么当第一个字节的二进制的第一位为1时，最大值 1111 1111 那么极有可能超出了一字节能代表的数字（255）。

如果这里采用如果第一个字节的二进制的第一位为1时
就判断第二位是否为0空闲，如果第二位同样为1时，
就继续判断第三位是否为0空闲。
当全部值都为1时，则使用两个字节表示。
会变成牺牲性能节省空间，不可取。
```

#### 2.1.2 NULL值列表

在列表中某些列可能存储`NULL`值，如果把`NULL`值放在记录的真实数据中存储会很占地方，所以Compact行格式会把这些值统一管理，
存储到NULL值列表中，存储过程如下：

1.统计表中允许存储NULL的列又哪些。

主键列、被NOT NULL修饰的列都不可以存储NULL值。

2.如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：
- 1 代表该列值为 NULL
- 0 代表该列值不为NULL

同样NULL值列表也是按照逆序排列。

3.MySQL规定 NULL值列表必须用整个字节位表示，如果不足整个位字节，则高位补0。如果超过一个字节数量的列允许为NULL，则采用两个字节表示。
对于我们的数据，c1、c3、c4 允许为 NULL，那么第一列的NULL值列表为：00000000，第二列的值 c3、c4都为 NULL，那么NULL值列表为：00000110
00000000顺序为：00000c4c3c1，00000110同样为：00000c4c3c1。

#### 2.1.3 记录头信息
//TODO
