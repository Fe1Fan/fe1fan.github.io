---
title: "MySQL 笔记6：存储"
date: 2020-10-07T14:23:52+08:00
tags: [mysql]
---
<!--more-->
# 存储
本文以InnoDB为例，讲述MySQL InnoDB引擎的存储结构。

## 1.0 页
> InnoDB管理存储空间的基本单位，大小一般为16KB。
> 
> 同时作为读取写入的基本单位。

InnoDB页分多种类型，今天具体讲解的是存放记录的页: 索引(INDEX)页。

数据页结构如下:
![image.png](https://i.loli.net/2021/05/18/mitERb5OZzch9JW.png)

|名称|中文名|占用空间|简单描述|
|----|----|----|----|
|File Header|文件头部|38字节|页的一些通用信息|
|Page Header|页面头部|56字节|数据页专有的一些信息|
|Infimum + Supremum|最小记录和最大记录|26字节|两个虚拟的行记录|
|User Records|用户记录|不确定|实际存储的行记录内容|
|Free Space|空闲空间|不确定|页中尚未使用的空间|
|Page Directory|页面目录|不确定|页中的某些记录的相对位置|
|File Trailer|文件尾部|8字节|校验页是否完整|


### 1.1 数据的写入
当页刚创建时，不存在 User Records 分区，当我们新增一条数据时，都会从 Free Space 申请一个记录大小的空间划分到 User Records，当 Free Space 使用完之后
如果还有新的记录新增，那么再去申请新的页。

具体流程如下：

![image.png](https://i.loli.net/2021/05/18/C91c28UyHXIj6kN.png)


## 2.0 行格式

当我们以记录为单位向表中插入数据，这些记录在磁盘上存放的格式被称为行格式或者记录格式。

InnoDB中的行格式如下：
- Compact
- Redundant
- Dynamic
- Compressed

指定行格式：

```sql
CREATE TABLE test ROW_FORMAT=Compact
ALTER TABLE test ROW_FORMAT=Compact
```

### 2.1 Compact

结构：
```shell
[变长字段长度列表][NULL值列表][记录头信息]  [列1的值][列2的值]...[列N的值]
|------------------------------------||--------------------------|
            记录额外信息                      记录真实数据
```

记录额外信息：

这部分信息是服务器为了描述这条记录而不得不添加的一些信息。

#### 2.1.1 变长字段长度列表

主要用于记录VARCHAR VARBINARY TEXT 这种不固定长度占用的字节数，**以逆序放**，所以说这些数据被分为两部分记录，一部分为真实的数据、一部分为占用的字节数。

假如表结构：
```sql
CREATE TABLE record_format_demo (
    ->     c1 VARCHAR(10),
    ->     c2 VARCHAR(10) NOT NULL,
    ->     c3 CHAR(10),
    ->     c4 VARCHAR(10)
    -> ) CHARSET=ascii ROW_FORMAT=COMPACT;
```

数据：

```shell
+------+-----+------+------+
| c1   | c2  | c3   | c4   |
+------+-----+------+------+
| aaaa | bbb | cc   | d    |
| eeee | fff | NULL | NULL |
+------+-----+------+------+
```

表使用ascii编码，所以每个字符只需要1个字节进行编码，所以长度为：


|列名|内容|长度|长度0x|
|----|----|----|----|
|c1|'aaaa'|4|0x04|
|c2|'bbb'|3|0x03|
|c4|'d'|1|0x01|

将这些长度倒叙存放，我们得到数据：
```shell
010304
```
所以 `[变长字段长度列表] = 010304`。

由于当前表采用ascii编码且c1、c2、c4字符串较短，长度用1个字节就可以表示，如果字符串较长时，就需要2个字节来表示。

InnoDB计算需要几个字节来表示的规则:

首先声明 W、M、L的意思
- W 

字符集表示一个字符最多需要的字节数，例如utf8 W=3（这里注意，MySQL utf8字符集采用最多3字节数，utf8mb4采用最多4字节数），gbk W=2，ascii W=1。

- M

对于VARCHAR(M) 这种可变长度的类型来说，这个类型最多存储M个字符（不是字节），所以说最多存储的字节数为 MxW。

- L

假设它实际存储的字符串占用的字节数是L。

InnoDB计算规则如下：

- 如果 `MxW <= 255` 那么采用1字节来表示真正的字符串占用字节数。 

  InnoDB在读记录的变长字段长度列表时，先查看表结构，如果某个变长字段允许储存的最大字节数不超过255，那么认为只是用1个字节来表示占用字节数。
- 如果 `MxW > 255` 
  - `L <= 127` 则采用1个字节表示。
  - `L > 127` 则采用2个字节表示。
  
  InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个字段允许存储最大字节数超过255时，假如值为 `0x7F` 二进制的 `0111 1111`，当读取到二进制的第一位为0时，
  那么该字节就是一个完整的字段长度，假如值为 `0x80` 二进制的 `1000 0000`，那么该字节为半个字段长度，值就为 `1000 0000 1000 0000`,当字段很长时，InnoDB会把一部分数据放到溢出页（后续），
  使得留在本页面中的长度使用两个字节也可存放。

InnoDB在读记录的变长字段长度列表时先查看表结构，当允许最大字节数小于等于255时，采用一个字节表示 比如当前存储了255字节，那么变长字段长度列表值为：
1111 1111。


//TODO 有待商榷
当最大允许字节数大于255时，分两种情况，如果真实记录长度小于等于127时，使用一个字节，比如当前存储了127字节，那么变长字段长度列表值为：
0111 1111。当真实记录长度大于127时，采用两个字节，比如说当前存储255字节，那么变长字段长度列表值为：1000 0000 1111 1111，其中最前面的1不计入长度计算，
只作为标识符。

##### CHAR
当我们使用ascii字符集，CHAR是固定的一个字节，不会被存储到变长字段长度列表中，但是使用gbk或utf8时，CHAR的长度也会被存入变长字段长度列表。

另外 utf8字符集的CHAR(10)来说，可存储范围是10-30字节，那么我们往里面写入一个空字符，也会占用10字节。

#### 2.1.2 NULL值列表

在列表中某些列可能存储`NULL`值，如果把`NULL`值放在记录的真实数据中存储会很占地方，所以Compact行格式会把这些值统一管理，
存储到NULL值列表中，存储过程如下：

1.统计表中允许存储NULL的列又哪些。

主键列、被NOT NULL修饰的列都不可以存储NULL值。

2.如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：
- 1 代表该列值为 NULL
- 0 代表该列值不为NULL

同样NULL值列表也是按照逆序排列。

3.MySQL规定 NULL值列表必须用整个字节位表示，如果不足整个位字节，则高位补0。如果超过一个字节数量的列允许为NULL，则采用两个字节表示。
对于我们的数据，c1、c3、c4 允许为 NULL，那么第一列的NULL值列表为：00000000，第二列的值 c3、c4都为 NULL，那么NULL值列表为：00000110

00000000顺序为：00000c4c3c1，
00000110同样为：00000c4c3c1。

#### 2.1.3 记录头信息
紧跟着 NULL值列表的是记录头信息，它由固定的5个字节组成，5个字节也就是40个二进制位，结构如下：

![image.png](https://i.loli.net/2021/05/18/aoWOTQxGJCyXltK.png)

|名称|大小|描述|
|----|----|----|
|预留位1|1|没有使用|
|预留位2|1|没有使用|
|delete_mask|1|标记该记录是否被删除|
|min_rec_mask|1|B+树的每层非叶子节点中的最小记录都会添加该标记|
|n_owned|4|表示当前记录拥有的记录数|
|heap_no|13|表示当前记录在记录堆的位置信息|
|record_type|3|表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录|
|next_record|16|表示下一条记录的相对位置|

#### 2.1.4 记录的真实数据

记录的真实数据除了记录自定义的列的数据外，MySQL会为每个记录默认添加一些列，也称为隐藏列，具体列如下：

|列名|是否必须|占用空间|描述|
|----|----|----|----|
|DB_ROW_ID|否|6字节|行ID，唯一标识一条记录|
|DB_TRX_ID|是|6字节|事务ID|
|DB_ROLL_PTR|是|7字节|回滚指针|

DB_ROW_ID:

InnoDB对主键生成的策略为：优先使用用户自定义的主键作为主键，如果没有，则选取一个 Unique 键作为主键，如果没有，则默认添加一个名为 DB_ROW_ID 的隐藏列
作为主键。

综上所述，真实的记录数据为：

![image.png](https://i.loli.net/2021/05/18/69YgVyfFDIqZnx1.png)

- 第一条记录中的 c3 是 CHAR(10) 但是世纪存储 'cc' ASCII编码为0x6363 其它8个字节使用空格填充，也就是ASCII的 0x20
- 对于CHAR(10)，如果使用ASCII编码，固定使用一个字节存储，假如使用 gbk 获取 utf8 这种不确定字节数的，c3列长度也会存储到
变长字段长度列表中。
  

### 2.2 Redundant
Redundant 行格式是MySQL5.0之前的一种行格式，结构如下：
![image.png](https://i.loli.net/2021/05/18/KYykHlO9NcpFnwZ.png)

以上一节的数据为例，当我们把行格式改为Redundant时，数据变成如下格式：

![image.png](https://i.loli.net/2021/05/18/3n7AkjdN1IaWxSU.png)

#### 2.2.1 字段长度偏移列表

在Compact行格式中，开头的时变长字段长度列表，而 Redundant 行格式中，开头则是字段长度偏移列表，他们不同的点是：
- 没有了变长两字节，也就是说 Redundant 行格式会把该记录中所有列包括隐藏列的长度信息都按照逆序存储在 字段长度偏移列表中。
- 多了个偏移两个字，字段长度偏移列表采用的是两个相邻的差值来激素哪个列值的长度。

比如第一条记录中 字段长度偏移列表为：

```shell
25 24 1A 17 13 0C 06
```

因为它也是逆序，按照正序排列为：

```shell
06 0C 13 17 1A 24 25
```
DB_ROW_ID 长度为 0x06
DB_TRX_ID 长度为 0x0C - 0x06 也是 0x06
后面以此类推

#### 2.2.2 记录头信息

Redundant 记录头信息共占6个字节，48位，结构如下：

|名称|大小|描述|
|----|----|----|
|预留位1|1|没有使用|
|预留位2|1|没有使用|
|delete_mask|1|标记该记录是否被删除|
|min_rec_mask|1|B+树的每层非叶子节点中的最小记录都会添加该标记|
|n_owned|4|表示当前记录拥有的记录数|
|heap_no|13|表示当前记录在页面堆的位置信息|
|n_field|10|表示记录中列的数量|
|1byte_offs_flag|1|标记字段长度偏移列表中的偏移量是使用1字节还是2字节表示的|
|next_record|16|表示下一条记录的相对位置|

1byte_offs_flag的选择：

字段长度偏移列表实质上是存储每个列中的值占用的空间在记录真实数据处结束的位置。

- 当记录的真实数据占用的字节数不大于127，占用1个字节。
- 当记录真实数据占用的字节大于127但小于等于32767（十六进制0x7FFF，二进制0111111111111111）时，占用两个字节。
- 当超过32767，记录存放在溢出页。

与 Compact 相反，当1byte_offs_flag的第一位为1时，则采用一个字节，为0时则采用两个字节。

Redundant没有NULL值列表，在字段长度偏移列表中对各个列的偏移量做了一些特殊处理，将列对应的偏移量值的第一个比特作为是否是NULL的依据，
该位被称为NULL比特位，如果该值是1那么个该列是NULL，否则不是NULL。

#### CHAR
不管使用的字符集是什么，空间始终为 字符集最大长度 x 最多需要字节数。

### 2.3 Dynamic和Compressed

//TODO

### 2.4 行溢出数据

VARCHAR(M) 类型的列最多可以占用 65535个字节，但是MySQL对一条记录占用的最大存储空间有限制，除了BOLB和TEXT类型外，其它
的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节。

当我们存储VARCHAR(M) 类型的数据时，实际占了三部分空间：

- 真实数据
- 真实数据占用字节的长度
- NULL 值列表

如果 VARCHAR 没有NOT NULL 属性，那么最多存储 65532 个字节数据，因为真实数据长度可能占用2个字节，NULL 值标识需要占用1个字节。

如果 VARCHAR 有NOT NULL 属性，那么最多存储 65522 个字节，因为真实数据长度可能占用2个字节。

假如列使用的时 ascii 字符集，那么最多就是如上如述。

假如使用列使用的时 gbk 或 utf8 字符，65532/2 或 65532/3，长度按最多占用算。


#### 2.4.1 数据溢出

当VARCHAR(M)存储过多的字符时，在 Compact 和 Redundant 行格式中，在记录真实数据处只会记录一部分数据，
把剩余的数据分散储存到其他几个页中，然后在记录真实数据处用20个字节存储指向这些页的地址，这20个字节还包括这些分散在其它数据页
重的数据的占用的字节数。

如下图：

![image.png](https://i.loli.net/2021/05/23/VuzpxFea2gwEAbq.png)

#### 2.4.2 行溢出临界值

MySQL中规定一个页至少存放两行记录。

假设表结构中只存在一个VARCHAR类型的数据，那么我们计算如下：

- 每个页除了存放记录值外，也会存放一些额外信息（下面讲），一个页中乱七八糟的额外数据加起来需要132个字节。
- 每个记录需要的额外信息是27字节。
  - 2个字节用于存储真实的数据的长度
  - 1个字节用于存储是否是NULL值
  - 5个字节头信息
  - 6个字节的DB_ROW_ID
  - 6个字节的DB_TRX_ID
  - 7个字节的DB_ROLL_PTR
  
假设列中存储的数据字节数为n,则满足下面这个条件
```shell
132 + 2 × ( 27 + n ) < 16384
```
也就是说，当n小于8099则不会溢出，否则会溢出。
