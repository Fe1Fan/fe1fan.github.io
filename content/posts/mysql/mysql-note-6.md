---
title: "MySQL 笔记6：存储"
date: 2020-10-07T14:23:52+08:00
tags: [mysql]
---
<!--more-->
# 存储
本文以InnoDB为例，讲述MySQL InnoDB引擎的存储结构。

## 1.0 页
> InnoDB管理存储空间的基本单位，大小一般为16KB。
> 
> 同时作为读取写入的基本单位。

InnoDB页分多种类型，今天具体讲解的是存放记录的页: 索引(INDEX)页。

数据页结构如下:
![image.png](https://i.loli.net/2021/05/18/mitERb5OZzch9JW.png)

|名称|中文名|占用空间|简单描述|
|----|----|----|----|
|File Header|文件头部|38字节|页的一些通用信息|
|Page Header|页面头部|56字节|数据页专有的一些信息|
|Infimum + Supremum|最小记录和最大记录|26字节|两个虚拟的行记录|
|User Records|用户记录|不确定|实际存储的行记录内容|
|Free Space|空闲空间|不确定|页中尚未使用的空间|
|Page Directory|页面目录|不确定|页中的某些记录的相对位置|
|File Trailer|文件尾部|8字节|校验页是否完整|


### 1.1 数据的写入
当页刚创建时，不存在 User Records 分区，当我们新增一条数据时，都会从 Free Space 申请一个记录大小的空间划分到 User Records，当 Free Space 使用完之后
如果还有新的记录新增，那么再去申请新的页。

具体流程如下：

![image.png](https://i.loli.net/2021/05/18/C91c28UyHXIj6kN.png)

//THIS TODO COMING


## 2.0 行格式

当我们以记录为单位向表中插入数据，这些记录在磁盘上存放的格式被称为行格式或者记录格式。

InnoDB中的行格式如下：
- Compact
- Redundant
- Dynamic
- Compressed

指定行格式：

```sql
CREATE TABLE test ROW_FORMAT=Compact
ALTER TABLE test ROW_FORMAT=Compact
```

### 2.1 Compact

结构：
```shell
[变长字段长度列表][NULL值列表][记录头信息]  [列1的值][列2的值]...[列N的值]
|------------------------------------||--------------------------|
            记录额外信息                      记录真实数据
```

记录额外信息：

这部分信息是服务器为了描述这条记录而不得不添加的一些信息。

#### 2.1.1 变长字段长度列表

主要用于记录VARCHAR VARBINARY TEXT 这种不固定长度占用的字节数，**以逆序放**，所以说这些数据被分为两部分记录，一部分为真实的数据、一部分为占用的字节数。

假如表结构：
```sql
CREATE TABLE record_format_demo (
    ->     c1 VARCHAR(10),
    ->     c2 VARCHAR(10) NOT NULL,
    ->     c3 CHAR(10),
    ->     c4 VARCHAR(10)
    -> ) CHARSET=ascii ROW_FORMAT=COMPACT;
```

数据：

```shell
+------+-----+------+------+
| c1   | c2  | c3   | c4   |
+------+-----+------+------+
| aaaa | bbb | cc   | d    |
| eeee | fff | NULL | NULL |
+------+-----+------+------+
```

表使用ascii编码，所以每个字符只需要1个字节进行编码，所以长度为：


|列名|内容|长度|长度0x|
|----|----|----|----|
|c1|'aaaa'|4|0x04|
|c2|'bbb'|3|0x03|
|c4|'d'|1|0x01|

将这些长度倒叙存放，我们得到数据：
```shell
010304
```
所以 `[变长字段长度列表] = 010304`。

由于当前表采用ascii编码且c1、c2、c4字符串较短，长度用1个字节就可以表示，如果字符串较长时，就需要2个字节来表示。

InnoDB计算需要几个字节来表示的规则:

首先声明 W、M、L的意思
- W 

字符集表示一个字符最多需要的字节数，例如utf8 W=3（这里注意，MySQL utf8字符集采用最多3字节数，utf8mb4采用最多4字节数），gbk W=2，ascii W=1。

- M

对于VARCHAR(M) 这种可变长度的类型来说，这个类型最多存储M个字符（不是字节），所以说最多存储的字节数为 MxW。

- L

假设它实际存储的字符串占用的字节数是L。（这里的L并不是获取到的真实占用字节数，而是代表占用字节数的第一个字节）

InnoDB计算规则如下：

- 如果 `MxW <= 255` 那么采用1字节来表示真正的字符串占用字节数。 

  InnoDB在读记录的变长字段长度列表时，先查看表结构，如果某个变长字段允许储存的最大字节数不超过255，那么认为只是用1个字节来表示占用字节数。
- 如果 `MxW > 255` 
  - `L <= 127` 则采用1字节表示。
  - `L > 127` 则采用2字节表示。
  
  InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个字段允许存储最大字节数超过255时，假如值为 `0x7F` 二进制的 `0111 1111`，当读取到二进制的第一位为0时，
  那么该字节就是一个完整的字段长度，假如值为 `0x80` 二进制的 `1000 0000`，那么该字节为半个字段长度，当字段很长时，InnoDB会把一部分数据放到溢出页（后续），
  使得留在本页面中的长度使用两个字节也可存放。

[comment]: <> (- 假如当前字节数使用一字节来表示，那么他的最大值：)

[comment]: <> (  1111 1111)

[comment]: <> (  ---------)

[comment]: <> (  1 byte)

[comment]: <> (- 假如当前字段需要两个字节来表示，那么它的最小值为:)

[comment]: <> (  1000 0000 0000 0000)

[comment]: <> (  --------- ---------)

[comment]: <> (  1 byte    2 byte)
```
//这里记录一下，以防忘记

[comment]: <> (当第一个字节的二进制的第一位为0时，它的最大值为 0x7F，也就是二进制的 0111 1111，十进制的127)

[comment]: <> (当第一个字节的二进制的第一位为1时，他的最小值为 0x80，也就是二进制的 1000 0000，十进制的128，最大值为255)

[comment]: <> (//用7位二进制代表数字理论上为2^7=128个，为什么最大值127而不是128 ？因为有 000 0000 = 0 的情况)

[comment]: <> (//8位二进制 255同上)

[comment]: <> (//这里为什么要这么设计？（猜想）)

[comment]: <> (在无法分辨当前字节数是需要一位还是两位来表示时：)

[comment]: <> (那么当第一个字节的二进制的第一位为0时，最大值 0111 1111 代表着还有一位空余未使用到。)

[comment]: <> (那么当第一个字节的二进制的第一位为1时，最大值 1111 1111 那么极有可能超出了一字节能代表的数字（255）。)

[comment]: <> (如果这里采用如果第一个字节的二进制的第一位为1时)

[comment]: <> (就判断第二位是否为0空闲，如果第二位同样为1时，)

[comment]: <> (就继续判断第三位是否为0空闲。)

[comment]: <> (当全部值都为1时，则使用两个字节表示。)

[comment]: <> (会变成牺牲性能节省空间，不可取。)
```

#### 2.1.2 NULL值列表

在列表中某些列可能存储`NULL`值，如果把`NULL`值放在记录的真实数据中存储会很占地方，所以Compact行格式会把这些值统一管理，
存储到NULL值列表中，存储过程如下：

1.统计表中允许存储NULL的列又哪些。

主键列、被NOT NULL修饰的列都不可以存储NULL值。

2.如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：
- 1 代表该列值为 NULL
- 0 代表该列值不为NULL

同样NULL值列表也是按照逆序排列。

3.MySQL规定 NULL值列表必须用整个字节位表示，如果不足整个位字节，则高位补0。如果超过一个字节数量的列允许为NULL，则采用两个字节表示。
对于我们的数据，c1、c3、c4 允许为 NULL，那么第一列的NULL值列表为：00000000，第二列的值 c3、c4都为 NULL，那么NULL值列表为：00000110
00000000顺序为：00000c4c3c1，00000110同样为：00000c4c3c1。

#### 2.1.3 记录头信息
紧跟着 NULL值列表的是记录头信息，它由固定的5个字节组成，5个字节也就是40个二进制位，结构如下：

![image.png](https://i.loli.net/2021/05/18/aoWOTQxGJCyXltK.png)

|名称|大小|描述|
|----|----|----|
|预留位1|1|没有使用|
|预留位2|1|没有使用|
|delete_mask|1|标记该记录是否被删除|
|min_rec_mask|1|B+树的每层非叶子节点中的最小记录都会添加该标记|
|n_owned|4|表示当前记录拥有的记录数|
|heap_no|13|表示当前记录在记录堆的位置信息|
|record_type|3|表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录|
|next_record|16|表示下一条记录的相对位置|

#### 2.1.4 记录的真实数据

记录的真实数据除了记录自定义的列的数据外，MySQL会为每个记录默认添加一些列，也称为隐藏列，具体列如下：

|列名|是否必须|占用空间|描述|
|----|----|----|----|
|DB_ROW_ID|否|6字节|行ID，唯一标识一条记录|
|DB_TRX_ID|是|6字节|事务ID|
|DB_ROLL_PTR|是|7字节|回滚指针|

DB_ROW_ID:

InnoDB对主键生成的策略为：优先使用用户自定义的主键作为主键，如果没有，则选取一个 Unique 键作为主键，如果没有，则默认添加一个名为 DB_ROW_ID 的隐藏列
作为主键。

综上所述，真实的记录数据为：

![image.png](https://i.loli.net/2021/05/18/69YgVyfFDIqZnx1.png)

- 第一条记录中的 c3 是 CHAR(10) 但是世纪存储 'cc' ASCII编码为0x6363 其它8个字节使用空格填充，也就是ASCII的 0x20
- 对于CHAR(10)，如果使用ASCII编码，固定使用一个字节存储，假如使用 gbk 获取 utf8 这种不确定字节数的，c3列长度也会存储到
变长字段长度列表中。
  

### 2.2 Redundant
Redundant 行格式是MySQL5.0之前的一种行格式，结构如下：
![image.png](https://i.loli.net/2021/05/18/KYykHlO9NcpFnwZ.png)

以上一节的数据为例，当我们把行格式改为Redundant时，数据变成如下格式：

![image.png](https://i.loli.net/2021/05/18/3n7AkjdN1IaWxSU.png)

#### 2.2.1 字段长度偏移列表

在Compact行格式中，开头的时变长字段长度列表，而 Redundant 行格式中，开头则是字段长度偏移列表，他们不同的点是：
- 没有了变长两字节，也就是说 Redundant 行格式会把该记录中所有列包括隐藏列的长度信息都按照逆序存储在 字段长度偏移列表中。
- 多了个偏移两个字，字段长度偏移列表采用的是两个相邻的差值来激素哪个列值的长度。

比如第一条记录中 字段长度偏移列表为：

```shell
25 24 1A 17 13 0C 06
```

因为它也是逆序，按照正序排列为：

```shell
06 0C 13 17 1A 24 25
```
DB_ROW_ID 长度为 0x06
DB_TRX_ID 长度为 0x0C - 0x06 也是 0x06
后面以此类推

#### 2.2.2 记录头信息

Redundant 记录头信息共占6个字节，48位，结构如下：

|名称|大小|描述|
|----|----|----|
|预留位1|1|没有使用|
|预留位2|1|没有使用|
|delete_mask|1|标记该记录是否被删除|
|min_rec_mask|1|B+树的每层非叶子节点中的最小记录都会添加该标记|
|n_owned|4|表示当前记录拥有的记录数|
|heap_no|13|表示当前记录在页面堆的位置信息|
|n_field|10|表示记录中列的数量|
|1byte_offs_flag|1|标记字段长度偏移列表中的偏移量是使用1字节还是2字节表示的|
|next_record|16|表示下一条记录的相对位置|

//TODO 


### 2.3 Dynamic和Compressed

//TODO
