---
title: "JVM 笔记2：垃圾回收"
date: 2020-10-07T14:23:52+08:00
tags: [jvm, java]
---

# JVM 垃圾回收

- 什么是垃圾
- 哪里需要垃圾回收
- 什么时候回收
- 怎么回收

## 什么是垃圾
当对象不再被需要的时候，就是需要被回收的垃圾。

## 哪里需要垃圾回收
1. Java堆

2. 方法区


## 什么时候回收
1.年轻代

当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，也就是新生代的GC。

2.老年代

在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看-XX：HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion Failure）；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX：HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。

3. 方法区
方法区主要回收两部分
- 废弃的常量
- 不再被使用的类型

3.1 常量：

当方法区的常量不再被任何一个对象引用时

不再被使用的类型：

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。

- 加载该类的类加载器已经被回收。

- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。


## 怎么回收
1.收集

2.清理


### 几种垃圾回收算法
- 分代收集
- 标记清除
- 标记复制
- 标记整理

#### 分代收集
- 弱分代假说：绝大多数对象都是朝生夕灭的。

- 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。

- 跨代引用假说：跨代引用相对于同代引用来说仅占极少数。

收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。
每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象。

把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。

#### 标记清除算法
首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。
![](https://i.loli.net/2020/10/17/bQtCuicBNw1mo9F.png)
#### 标记复制算法
为了解决标记清除算法面对大量可回收对象时执行效率低的问题
将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
![](https://i.loli.net/2020/10/17/KGg7wFDuBX453fc.png)
#### 标记整理
标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。
![](https://i.loli.net/2020/10/17/rHQ6Xholmq5O7RN.png)

### 第一步 收集&标记

#### 1.引用计数法（Reference Counting）

JVM 并没有采用大多数人所说的引用计数法，**是从来没有**。

##### 概念
在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。

##### 优点
原理简单，判定效率也很高

##### 缺陷
占用了一些额外的内存空间来进行计数

```java
class Demo {
    public Object object = null;
    
    public static void main(String[] args){
      Demo demoA = new Demo();
      Demo demoB = new Demo();
      demoA.object = demoB;
      demoB.object = demoA;
      
      demoA = null;
      demoB = null;
      //此时 demoA 和 demoB 都不会被回收
      System.gc();
    }
}
```