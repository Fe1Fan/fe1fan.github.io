<!doctype html><html><head><title>MySQL 笔记6：存储 // Fe1Fan</title><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="学习笔记"><meta property="og:title" content="MySQL 笔记6：存储"><meta property="og:description" content="学习笔记"><meta property="og:type" content="website"><meta property="og:locale" content="en"><meta property="og:url" content="https://fe1.fan/posts/mysql/mysql-note-6/"><link rel="shortcut icon" href=/favicon.ico><link href=https://fe1.fan/webfonts/ptserif/main.css rel=stylesheet type=text/css><link href=https://fe1.fan/webfonts/source-code-pro/main.css rel=stylesheet type=text/css><link rel=stylesheet href=https://fe1.fan/css/style.css><meta name=generator content="Hugo 0.75.1"></head><body><div id=container><header id=header><div id=header-outer class=outer><div id=header-inner class=inner><a id=main-nav-toggle class=nav-icon href=javascript:;></a><a id=logo class=logo-text href=https://fe1.fan/>Fe1Fan</a><nav id=main-nav><a class=main-nav-link href=/>主页</a>
<a class=main-nav-link href=/tags/>归档</a>
<a class=main-nav-link href=/about/>关于</a>
<a class=main-nav-link href=/index.xml>订阅</a></nav><nav id=sub-nav><div id=search-form-wrap></div></nav></div></div></header><section id=main class=outer><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 class=article-title itemprop=name>MySQL 笔记6：存储</h1></header><div class=article-meta><a href="/posts/mysql/mysql-note-6/?uid=91a329063146eef058647ad7f523b337" class=article-date><time datetime=2020-10-07T14:23:52.000+08:00 itemprop=datePublished>2020-10-07</time></a></div><div class=article-entry itemprop=articleBody><h1 id=存储>存储</h1><p>本文以InnoDB为例，讲述MySQL InnoDB引擎的存储结构。</p><h2 id=10-页>1.0 页</h2><blockquote><p>InnoDB管理存储空间的基本单位，大小一般为16KB。</p><p>同时作为读取写入的基本单位。</p></blockquote><p>InnoDB页分多种类型，今天具体讲解的是存放记录的页: 索引(INDEX)页。</p><p>数据页结构如下:
<img src=https://i.loli.net/2021/05/18/mitERb5OZzch9JW.png alt=image.png></p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38字节</td><td>页的一些通用信息</td></tr><tr><td>Page Header</td><td>页面头部</td><td>56字节</td><td>数据页专有的一些信息</td></tr><tr><td>Infimum + Supremum</td><td>最小记录和最大记录</td><td>26字节</td><td>两个虚拟的行记录</td></tr><tr><td>User Records</td><td>用户记录</td><td>不确定</td><td>实际存储的行记录内容</td></tr><tr><td>Free Space</td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr><td>Page Directory</td><td>页面目录</td><td>不确定</td><td>页中的某些记录的相对位置</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8字节</td><td>校验页是否完整</td></tr></tbody></table><h3 id=11-数据的写入>1.1 数据的写入</h3><p>当页刚创建时，不存在 User Records 分区，当我们新增一条数据时，都会从 Free Space 申请一个记录大小的空间划分到 User Records，当 Free Space 使用完之后
如果还有新的记录新增，那么再去申请新的页。</p><p>具体流程如下：</p><p><img src=https://i.loli.net/2021/05/18/C91c28UyHXIj6kN.png alt=image.png></p><p>//THIS TODO COMING</p><h2 id=20-行格式>2.0 行格式</h2><p>当我们以记录为单位向表中插入数据，这些记录在磁盘上存放的格式被称为行格式或者记录格式。</p><p>InnoDB中的行格式如下：</p><ul><li>Compact</li><li>Redundant</li><li>Dynamic</li><li>Compressed</li></ul><p>指定行格式：</p><pre><code class=language-sql>CREATE TABLE test ROW_FORMAT=Compact
ALTER TABLE test ROW_FORMAT=Compact
</code></pre><h3 id=21-compact>2.1 Compact</h3><p>结构：</p><pre><code class=language-shell>[变长字段长度列表][NULL值列表][记录头信息]  [列1的值][列2的值]...[列N的值]
|------------------------------------||--------------------------|
            记录额外信息                      记录真实数据
</code></pre><p>记录额外信息：</p><p>这部分信息是服务器为了描述这条记录而不得不添加的一些信息。</p><h4 id=211-变长字段长度列表>2.1.1 变长字段长度列表</h4><p>主要用于记录VARCHAR VARBINARY TEXT 这种不固定长度占用的字节数，<strong>以逆序放</strong>，所以说这些数据被分为两部分记录，一部分为真实的数据、一部分为占用的字节数。</p><p>假如表结构：</p><pre><code class=language-sql>CREATE TABLE record_format_demo (
    -&gt;     c1 VARCHAR(10),
    -&gt;     c2 VARCHAR(10) NOT NULL,
    -&gt;     c3 CHAR(10),
    -&gt;     c4 VARCHAR(10)
    -&gt; ) CHARSET=ascii ROW_FORMAT=COMPACT;
</code></pre><p>数据：</p><pre><code class=language-shell>+------+-----+------+------+
| c1   | c2  | c3   | c4   |
+------+-----+------+------+
| aaaa | bbb | cc   | d    |
| eeee | fff | NULL | NULL |
+------+-----+------+------+
</code></pre><p>表使用ascii编码，所以每个字符只需要1个字节进行编码，所以长度为：</p><table><thead><tr><th>列名</th><th>内容</th><th>长度</th><th>长度0x</th></tr></thead><tbody><tr><td>c1</td><td>&lsquo;aaaa&rsquo;</td><td>4</td><td>0x04</td></tr><tr><td>c2</td><td>&lsquo;bbb&rsquo;</td><td>3</td><td>0x03</td></tr><tr><td>c4</td><td>&rsquo;d'</td><td>1</td><td>0x01</td></tr></tbody></table><p>将这些长度倒叙存放，我们得到数据：</p><pre><code class=language-shell>010304
</code></pre><p>所以 <code>[变长字段长度列表] = 010304</code>。</p><p>由于当前表采用ascii编码且c1、c2、c4字符串较短，长度用1个字节就可以表示，如果字符串较长时，就需要2个字节来表示。</p><p>InnoDB计算需要几个字节来表示的规则:</p><p>首先声明 W、M、L的意思</p><ul><li>W</li></ul><p>字符集表示一个字符最多需要的字节数，例如utf8 W=3（这里注意，MySQL utf8字符集采用最多3字节数，utf8mb4采用最多4字节数），gbk W=2，ascii W=1。</p><ul><li>M</li></ul><p>对于VARCHAR(M) 这种可变长度的类型来说，这个类型最多存储M个字符（不是字节），所以说最多存储的字节数为 MxW。</p><ul><li>L</li></ul><p>假设它实际存储的字符串占用的字节数是L。</p><p>InnoDB计算规则如下：</p><ul><li><p>如果 <code>MxW &lt;= 255</code> 那么采用1字节来表示真正的字符串占用字节数。</p><p>InnoDB在读记录的变长字段长度列表时，先查看表结构，如果某个变长字段允许储存的最大字节数不超过255，那么认为只是用1个字节来表示占用字节数。</p></li><li><p>如果 <code>MxW > 255</code></p><ul><li><code>L &lt;= 127</code> 则采用1字节表示。</li><li><code>L > 127</code> 则采用2字节表示。</li></ul><p>InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个字段允许存储最大字节数超过255时，假如值为 <code>0x7F</code> 二进制的 <code>0111 1111</code>，当读取到二进制的第一位为0时，
那么该字节就是一个完整的字段长度，假如值为 <code>0x80</code> 二进制的 <code>1000 0000</code>，那么该字节为半个字段长度，值就为 <code>1000 0000 1000 0000</code>,当字段很长时，InnoDB会把一部分数据放到溢出页（后续），
使得留在本页面中的长度使用两个字节也可存放。</p></li></ul><p>InnoDB在读记录的变长字段长度列表时先查看表结构，当允许最大字节数小于等于255时，采用一个字节表示 比如当前存储了255字节，那么变长字段长度列表值为：
1111 1111。</p><p>//TODO 有待商榷
当最大允许字节数大于255时，分两种情况，如果真实记录长度小于等于127时，使用一个字节，比如当前存储了127字节，那么变长字段长度列表值为：
0111 1111。当真实记录长度大于127时，采用两个字节，比如说当前存储255字节，那么变长字段长度列表值为：1000 0000 1111 1111，其中最前面的1不计入长度计算，
只作为标识符。</p><h4 id=212-null值列表>2.1.2 NULL值列表</h4><p>在列表中某些列可能存储<code>NULL</code>值，如果把<code>NULL</code>值放在记录的真实数据中存储会很占地方，所以Compact行格式会把这些值统一管理，
存储到NULL值列表中，存储过程如下：</p><p>1.统计表中允许存储NULL的列又哪些。</p><p>主键列、被NOT NULL修饰的列都不可以存储NULL值。</p><p>2.如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：</p><ul><li>1 代表该列值为 NULL</li><li>0 代表该列值不为NULL</li></ul><p>同样NULL值列表也是按照逆序排列。</p><p>3.MySQL规定 NULL值列表必须用整个字节位表示，如果不足整个位字节，则高位补0。如果超过一个字节数量的列允许为NULL，则采用两个字节表示。
对于我们的数据，c1、c3、c4 允许为 NULL，那么第一列的NULL值列表为：00000000，第二列的值 c3、c4都为 NULL，那么NULL值列表为：00000110
00000000顺序为：00000c4c3c1，00000110同样为：00000c4c3c1。</p><h4 id=213-记录头信息>2.1.3 记录头信息</h4><p>紧跟着 NULL值列表的是记录头信息，它由固定的5个字节组成，5个字节也就是40个二进制位，结构如下：</p><p><img src=https://i.loli.net/2021/05/18/aoWOTQxGJCyXltK.png alt=image.png></p><table><thead><tr><th>名称</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><h4 id=214-记录的真实数据>2.1.4 记录的真实数据</h4><p>记录的真实数据除了记录自定义的列的数据外，MySQL会为每个记录默认添加一些列，也称为隐藏列，具体列如下：</p><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>DB_ROW_ID</td><td>否</td><td>6字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td>DB_TRX_ID</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>DB_ROLL_PTR</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><p>DB_ROW_ID:</p><p>InnoDB对主键生成的策略为：优先使用用户自定义的主键作为主键，如果没有，则选取一个 Unique 键作为主键，如果没有，则默认添加一个名为 DB_ROW_ID 的隐藏列
作为主键。</p><p>综上所述，真实的记录数据为：</p><p><img src=https://i.loli.net/2021/05/18/69YgVyfFDIqZnx1.png alt=image.png></p><ul><li>第一条记录中的 c3 是 CHAR(10) 但是世纪存储 &lsquo;cc&rsquo; ASCII编码为0x6363 其它8个字节使用空格填充，也就是ASCII的 0x20</li><li>对于CHAR(10)，如果使用ASCII编码，固定使用一个字节存储，假如使用 gbk 获取 utf8 这种不确定字节数的，c3列长度也会存储到
变长字段长度列表中。</li></ul><h3 id=22-redundant>2.2 Redundant</h3><p>Redundant 行格式是MySQL5.0之前的一种行格式，结构如下：
<img src=https://i.loli.net/2021/05/18/KYykHlO9NcpFnwZ.png alt=image.png></p><p>以上一节的数据为例，当我们把行格式改为Redundant时，数据变成如下格式：</p><p><img src=https://i.loli.net/2021/05/18/3n7AkjdN1IaWxSU.png alt=image.png></p><h4 id=221-字段长度偏移列表>2.2.1 字段长度偏移列表</h4><p>在Compact行格式中，开头的时变长字段长度列表，而 Redundant 行格式中，开头则是字段长度偏移列表，他们不同的点是：</p><ul><li>没有了变长两字节，也就是说 Redundant 行格式会把该记录中所有列包括隐藏列的长度信息都按照逆序存储在 字段长度偏移列表中。</li><li>多了个偏移两个字，字段长度偏移列表采用的是两个相邻的差值来激素哪个列值的长度。</li></ul><p>比如第一条记录中 字段长度偏移列表为：</p><pre><code class=language-shell>25 24 1A 17 13 0C 06
</code></pre><p>因为它也是逆序，按照正序排列为：</p><pre><code class=language-shell>06 0C 13 17 1A 24 25
</code></pre><p>DB_ROW_ID 长度为 0x06
DB_TRX_ID 长度为 0x0C - 0x06 也是 0x06
后面以此类推</p><h4 id=222-记录头信息>2.2.2 记录头信息</h4><p>Redundant 记录头信息共占6个字节，48位，结构如下：</p><table><thead><tr><th>名称</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在页面堆的位置信息</td></tr><tr><td>n_field</td><td>10</td><td>表示记录中列的数量</td></tr><tr><td>1byte_offs_flag</td><td>1</td><td>标记字段长度偏移列表中的偏移量是使用1字节还是2字节表示的</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><p>//TODO</p><h3 id=23-dynamic和compressed>2.3 Dynamic和Compressed</h3><p>//TODO</p></div><div class=article-toc><h3>Contents</h3><nav id=TableOfContents><ul><li><a href=#10-页>1.0 页</a><ul><li><a href=#11-数据的写入>1.1 数据的写入</a></li></ul></li><li><a href=#20-行格式>2.0 行格式</a><ul><li><a href=#21-compact>2.1 Compact</a></li><li><a href=#22-redundant>2.2 Redundant</a></li><li><a href=#23-dynamic和compressed>2.3 Dynamic和Compressed</a></li></ul></li></ul></nav></div><footer class=article-footer><ul class=article-tag-list><li class=article-tag-list-item><a class=article-tag-list-link href=https://fe1.fan/tags/mysql>mysql</a></li></ul></footer></div><nav id=article-nav><a href=/posts/mysql/mysql-note-2/ id=article-nav-newer class=article-nav-link-wrap><div class=article-nav-title><span>&lt;</span>&nbsp;
MySQL 笔记2：架构</div></a><a href=/posts/redis/redis-note-1/ id=article-nav-older class=article-nav-link-wrap><div class=article-nav-title>Redis 笔记1：基础&nbsp;<span>></span></div></a></nav></article></section><footer id=footer><div class=outer><div id=footer-info class=inner>&copy; 2021 Fe1Fan<br>Powered by <a href=https://gohugo.io target=_blank>Hugo</a> with theme <a href=https://github.com/carsonip/hugo-theme-minos target=_blank>Minos</a></div></div><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/tomorrow-night.min.css integrity="sha256-2wL88NKUqvJi/ExflDzkzUumjUM73mcK2gBvBBeLvTk=" crossorigin=anonymous><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin=anonymous></script><script>hljs.initHighlightingOnLoad();</script><script>document.getElementById('main-nav-toggle').addEventListener('click',function(){var header=document.getElementById('header');if(header.classList.contains('mobile-on')){header.classList.remove('mobile-on');}else{header.classList.add('mobile-on');}});</script></footer></div></body></html>