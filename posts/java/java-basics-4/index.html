<!doctype html><html><head><title>Java基础知识4-锁 // Fe1Fan</title><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="学习笔记"><meta property="og:title" content="Java基础知识4-锁"><meta property="og:description" content="学习笔记"><meta property="og:type" content="website"><meta property="og:locale" content="en"><meta property="og:url" content="https://fe1.fan/posts/java/java-basics-4/"><link rel="shortcut icon" href=/favicon.ico><link href=https://fe1.fan/webfonts/ptserif/main.css rel=stylesheet type=text/css><link href=https://fe1.fan/webfonts/source-code-pro/main.css rel=stylesheet type=text/css><link rel=stylesheet href=https://fe1.fan/css/style.css><meta name=generator content="Hugo 0.75.1"></head><body><div id=container><header id=header><div id=header-outer class=outer><div id=header-inner class=inner><a id=main-nav-toggle class=nav-icon href=javascript:;></a><a id=logo class=logo-text href=https://fe1.fan/>Fe1Fan</a><nav id=main-nav><a class=main-nav-link href=/>主页</a>
<a class=main-nav-link href=/tags/>归档</a>
<a class=main-nav-link href=/about/>关于</a>
<a class=main-nav-link href=/index.xml>订阅</a></nav><nav id=sub-nav><div id=search-form-wrap></div></nav></div></div></header><section id=main class=outer><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 class=article-title itemprop=name>Java基础知识4-锁</h1></header><div class=article-meta><a href="/posts/java/java-basics-4/?uid=dafcc5ba71722663cb4244fa08c7a1e2" class=article-date><time datetime=2020-10-07T14:23:52.000+08:00 itemprop=datePublished>2020-10-07</time></a></div><div class=article-entry itemprop=articleBody><hr><h1 id=10-锁类型>1.0 锁类型</h1><ul><li>悲观锁</li><li>乐观锁</li><li>自旋锁</li><li>适应性自旋锁</li><li>无锁</li><li>偏向锁</li><li>轻量级锁</li><li>重量级锁</li><li>公平锁</li><li>非公平锁</li><li>可重入锁</li><li>非可重入锁</li><li>共享锁</li><li>排他锁</li></ul><p><img src=https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png alt=111></p><h2 id=悲观锁>悲观锁</h2><blockquote><p>对于同一个数据在并发操作，认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p></blockquote><p>适合写操作多的场景，先加锁可以保证写操作时数据正确。</p><p>在Java中 synchronized 和 Lock的实现类都是悲观锁。</p><ul><li>ReadLock</li><li>ReadLockView</li><li>ReentrantLock</li><li>WriteLock</li><li>WriteLockView</li></ul><h2 id=乐观锁>乐观锁</h2><blockquote><p>认为自己在使用数据时不会有别的线程修改数据，不会添加锁，在更新数据前判断数据是否被更改，如果更改，则根据不同的实现方式执行不同的操作。</p></blockquote><p>适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</p><p>乐观锁在Java中使用的是无锁的方式，最常采用的方法是CAS（Compare And Swap（比较与交换））算法，Java原子类中的递增操作就通过CAS自旋实现的。</p><p>CAS:</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。</li></ul><p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><p><img src=https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/c8703cd9.png alt></p><h2 id=自旋锁>自旋锁</h2><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态切换需要耗费处理器时间。如果同步代码块重的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步最远的锁定时间很短，为了这一小段时间去切换线程，过于奢侈，如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p><p><img src=https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/452a3363.png alt></p><p>自旋锁虽然避免了线程切换的开销，但是要占用处理器的时间，如果锁被占用时间很短，自旋锁效果就非常好，但如果占用时间过长，
那么将会浪费处理器资源，所以自旋锁必须要有限度，在Java中默认为10次，通过 <code>-XX:PreBlockSpin</code> 来修改，如果没有获取到，则挂起。</p><h2 id=适应性自旋锁>适应性自旋锁</h2><blockquote><p>自旋的时间和次数不再固定，由前一次在同一个锁上的自旋时间及锁的拥有者状态来决定。</p></blockquote><p>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么JVM就认为这次自旋也是很有可能成功的，允许等待更长时间，
如果某个对象自旋很少成功，那么接下来尝试获取可能会省掉自选过程，直接阻塞。</p><h2 id=无锁偏向锁轻量级锁重量级锁>无锁、偏向锁、轻量级锁、重量级锁</h2><p>synchronized 通过 Monitor 实现锁，在对象头中，主要包括两部分数据：</p><ul><li>Mark Word</li><li>Klass Pointer</li></ul><p>Mark Word：</p><p>默认存储对象的HashCode，分代年龄和锁标志位信息。</p><p>Klass Pointer：</p><p>对象指向它的类元素的指针，JVM通过这个指针确定对象是哪个类的实例。</p><p>Monitor 是线程私有的数据结构，每个线程都有一个可用的 monitor record 列表，同时还有一个全局的可用列表。</p><p>每一个被锁住的对象都会和一个 monitor 关联，同时 monitor 中又一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><p>Monitor是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的线程同步。</p><p>JDK1.6之前是使用 Mutex Lock 这种重量锁，1.6中引入了偏向锁和轻量级锁。</p><table><thead><tr><th>锁状态</th><th>存储内容</th><th>存储内容</th></tr></thead><tbody><tr><td>无锁</td><td>对象的hashCode、对象分代年龄、是否是偏向锁（0）</td><td>01</td></tr><tr><td>偏向锁</td><td>偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td><td>01</td></tr><tr><td>轻量级锁</td><td>指向栈中锁记录的指针</td><td>00</td></tr><tr><td>重量级锁</td><td>指向互斥量（重量级锁）的指针</td><td>10</td></tr></tbody></table><ul><li>当代码块不存在竞争时，无锁</li><li>当代码拿到代码块执行时，为偏向锁，偏向锁释放只会在安全点检查时，如果拿锁的线程活跃且有人竞争，升级为轻量锁，如果线程不活跃，为无锁。</li><li>轻量级锁适用于线程交替执行同步块，当升级为轻量级锁，其他线程自旋等待。</li><li>若其它线程自旋结束还未获得锁，升级为重量锁。</li></ul><h3 id=无锁>无锁</h3><p>修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。</p><h3 id=偏向锁>偏向锁</h3><blockquote><p>如果一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p></blockquote><p>当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储偏向的线程ID，在线程进入或退出代码块时，不再通过CAS操作来加锁和解锁，而是检测 Mark Word 里是否
存储着指向当前线程的偏向锁，偏向锁只需要在置换线程ID时依赖一次CAS原子指令。</p><p>偏向锁只有遇到其它线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁，偏向锁的撤销需要等待全局安全点，它会暂停拥有偏向锁的线程，
判断对象是否处于锁定状态，撤销后恢复到无锁或者轻量级锁状态。</p><h3 id=轻量级锁>轻量级锁</h3><blockquote><p>当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级成轻量锁，其他线程会采取自选的形式获取锁，不会阻塞，从而提高性能。</p></blockquote><p>在进入同步块的时候，如果同步对象为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储对象目前
的 Mark Word的拷贝，然后拷贝对象头中的 Mark Word 复制到锁记录中。</p><p>拷贝成功后，JVM将使用CAS操作尝试将对象头的 Mark Word 更新指向 Lock Record 的指针，并将 Lock Record 里的 owner指针指向对象的 Mark Word。</p><p>如果这个更新动作成功了，那么该线程就拥有了锁，并将对象更新处于轻量级锁状态。</p><p>如果失败了，会先检查 Mark Word 是否指向当前线程的栈帧，如果是 那就是拥有了锁，可以继续执行，如果不是，则说明多个线程竞争锁。</p><h3 id=重量级锁>重量级锁</h3><p>当锁升级为重量级锁的时候 等待线程会进入阻塞状态。</p><h3 id=公平锁和非公平锁>公平锁和非公平锁</h3><blockquote><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p></blockquote><blockquote><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p></blockquote><h3 id=可重入锁和非可重入锁>可重入锁和非可重入锁</h3><blockquote><p>是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁</p></blockquote><p>ReentrantLock和synchronized都是可重入锁</p><p>ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。</p><p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p><p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p><h3 id=独享锁和共享锁>独享锁和共享锁</h3><p>ReentrantLock和ReentrantReadWriteLock</p><p>ReentrantLock为独享锁</p><p>ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。</p><p>读锁是共享锁，写锁是独享锁。读写、写读、写写的过程互斥。
ReentrantReadWriteLock将state拆分为两位。高16位为读锁个数，低16位为写锁个数。</p></div><div class=article-toc><h3>Contents</h3><nav id=TableOfContents><ul><li><a href=#悲观锁>悲观锁</a></li><li><a href=#乐观锁>乐观锁</a></li><li><a href=#自旋锁>自旋锁</a></li><li><a href=#适应性自旋锁>适应性自旋锁</a></li><li><a href=#无锁偏向锁轻量级锁重量级锁>无锁、偏向锁、轻量级锁、重量级锁</a><ul><li><a href=#无锁>无锁</a></li><li><a href=#偏向锁>偏向锁</a></li><li><a href=#轻量级锁>轻量级锁</a></li><li><a href=#重量级锁>重量级锁</a></li><li><a href=#公平锁和非公平锁>公平锁和非公平锁</a></li><li><a href=#可重入锁和非可重入锁>可重入锁和非可重入锁</a></li><li><a href=#独享锁和共享锁>独享锁和共享锁</a></li></ul></li></ul></nav></div><footer class=article-footer><ul class=article-tag-list><li class=article-tag-list-item><a class=article-tag-list-link href=https://fe1.fan/tags/java%E5%9F%BA%E7%A1%80>java基础</a></li></ul></footer></div><nav id=article-nav><a href=/posts/java/java-basics-1/ id=article-nav-newer class=article-nav-link-wrap><div class=article-nav-title><span>&lt;</span>&nbsp;
Java基础知识1-引用和传递</div></a><a href=/posts/jvm/jvm-note-1/ id=article-nav-older class=article-nav-link-wrap><div class=article-nav-title>JVM 笔记1：内存管理&nbsp;<span>></span></div></a></nav></article></section><footer id=footer><div class=outer><div id=footer-info class=inner>&copy; 2021 Fe1Fan<br>Powered by <a href=https://gohugo.io target=_blank>Hugo</a> with theme <a href=https://github.com/carsonip/hugo-theme-minos target=_blank>Minos</a></div></div><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/tomorrow-night.min.css integrity="sha256-2wL88NKUqvJi/ExflDzkzUumjUM73mcK2gBvBBeLvTk=" crossorigin=anonymous><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin=anonymous></script><script>hljs.initHighlightingOnLoad();</script><script>document.getElementById('main-nav-toggle').addEventListener('click',function(){var header=document.getElementById('header');if(header.classList.contains('mobile-on')){header.classList.remove('mobile-on');}else{header.classList.add('mobile-on');}});</script></footer></div></body></html>