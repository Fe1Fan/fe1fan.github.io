<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Fe1Fan</title><link>https://fe1.fan/</link><description>Recent content on Fe1Fan</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 07 Oct 2020 14:23:52 +0800</lastBuildDate><atom:link href="https://fe1.fan/index.xml" rel="self" type="application/rss+xml"/><item><title>About</title><link>https://fe1.fan/about/</link><pubDate>Wed, 07 Oct 2020 14:35:26 +0800</pubDate><guid>https://fe1.fan/about/</guid><description>About Fe1Fan: Blog: https://fe1.fan
GitHub: https://github.com/Fe1Fan
AtlScript: https://github.com/autool/atlscript
&amp;hellip;</description></item><item><title>JVM 笔记1：内存管理</title><link>https://fe1.fan/posts/jvm/jvm_note_1/</link><pubDate>Wed, 07 Oct 2020 14:23:52 +0800</pubDate><guid>https://fe1.fan/posts/jvm/jvm_note_1/</guid><description>JVM-1 内存管理 程序计数器 (Program Counter Register) 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
简单来说就是记录程序执行到第几行了，每条线程有单独的程序计数器。
Java虚拟机栈 (Java Virtual Machine Stack) 与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
栈与栈帧 每一个方法的执行到执行完成，对应着一个栈帧在虚拟机中从入栈到出栈的过程。 虚拟机栈栈顶的栈帧就是当前执行方法的栈帧。 当这个方法调用其他方法的时候久会创建一个新的栈帧，这个新的栈帧会被放到Java虚拟机栈的栈顶，变为当前的活动栈。 当这个栈帧所有指令都完成的时候，这个栈帧被移除，之前的栈帧变为活动栈，前面移除栈帧的返回值变为这个栈帧的一个操作数。
栈帧 栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构,他是虚拟机栈元素。
栈帧存储了以下几类数据:
局部变量表 操作数栈 动态连接 方法返回地址 附加信息 局部变量表 局部变量表是用于储存变量的储存空间，用于存储方法的参数和方法的内部变量
操作数栈 算术运算与调用其它方法参数传递。
动态连接 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用
在一个class文件中，一个方法要调用其他方法，需要将这些方法的符号引用转化为其在内存地址中的直接引用，而符号引用存在于方法区中的运行时常量池。 每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态连接(Dynamic Linking)。
方法返回地址 当一个方法开始执行的时候有两种结束方式，正常结束和异常结束
执行引擎遇到任意一个方法返回的字节码指令:传递给上层的方法调用者，是否有返回值和返回值类型将根据遇到何种方法来返回指令决定，这种退出的方法称为正常完成出口。
在执行遇到异常且方法体内部没有搜寻到异常处理器的情况下。方法退出过程实际上就等同于把当前栈帧出栈，因此退出可以执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压如调用者的操作数栈中，调整PC计数器的值以指向方法调用指令后的下一条指令。
附加信息 虚拟机规范允许具体的虚拟机实现增加一些规范中没有描述的信息到栈帧之中，例如和调试相关的信息，这部分信息完全取决于不同的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其他附加信息一起归为一类，称为栈帧信息。
本地方法栈（Native Method Stacks） Native方法栈，HotSpot虚拟机把本地方法栈和虚拟机栈合二为一
Java堆（Java Heap） 概念：用于存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。
HotSpot： Old 老年代 Eden 新生代 Survivor0 临时交换区0 Survivor1 临时交换区1 Metaspace 元数据区域 Old 老年代 存放逃过N次（默认为15次）GC回收的对象、需要大量连续内存的新生对象。</description></item><item><title>JVM 笔记2：垃圾回收</title><link>https://fe1.fan/posts/jvm/jvm_note_2/</link><pubDate>Wed, 07 Oct 2020 14:23:52 +0800</pubDate><guid>https://fe1.fan/posts/jvm/jvm_note_2/</guid><description>JVM 垃圾回收 什么是垃圾 哪里需要垃圾回收 什么时候回收 怎么回收 什么是垃圾 当对象不再被需要的时候，就是需要被回收的垃圾。
哪里需要垃圾回收 Java堆
方法区
什么时候回收 1.年轻代
当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，也就是新生代的GC。
2.老年代
在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看-XX：HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion Failure）；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX：HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。
方法区 方法区主要回收两部分 废弃的常量 不再被使用的类型 常量：
当方法区的常量不再被任何一个对象引用时
不再被使用的类型：
该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
加载该类的类加载器已经被回收。
该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
垃圾回收的步骤 1.收集
2.清理
1.引用计数法（Reference Counting） JVM 并没有采用大多数人所说的引用计数法，是从来没有。
概念 在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。
优点 原理简单，判定效率也很高
缺陷 占用了一些额外的内存空间来进行计数
class Demo { public Object object = null; public static void main(String[] args){ Demo demoA = new Demo(); Demo demoB = new Demo(); demoA.</description></item></channel></rss>